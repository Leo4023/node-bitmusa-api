<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: bitmusa.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: bitmusa.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const request = require('request');
const querystring = require('querystring');

class Bitmusa {
    /**
     * Creates an instance of Bitmusa.
     * @param {string|Object} [options={}] - The API options. If string, the authentication key. If object, the options object.
     * @param {string} [options.authKey] - The authentication key.
     * @param {string} [options.baseURL=https://www.bitmusa.com/api] - The API base URL.
     * @param {number} [options.timeOut=1000] - The API request timeout in milliseconds.
     * @throws {Error} Invalid options.
     */
    constructor(options = {}) {
        if (typeof options === 'string') {
            this.options = Object.assign(this.getDefaultOptions(), { authKey: options });
        } else {
            if (typeof options === 'object') {
                if (Object.keys(options).length === 0) {
                    this.options = this.getDefaultOptions();
                } else {
                    this.options = Object.assign(this.getDefaultOptions(), options);
                }
            } else {
                throw new Error('[constructor] Invalid options');
            }
        }

    }

    /**
     * Returns the default options for the Bitmusa API.
     * @returns {Object} The default options object.
     */
    getDefaultOptions() {
        return {
            baseURL: 'https://www.bitmusa.com/api',
            timeOut: 1000
        }
    }

    /**
     * Creates a new instance of Bitmusa with the specified authentication key.
     * @param {string} authKey - The authentication key.
     * @returns {Bitmusa} The new Bitmusa instance.
     */
    createWithKey(authKey) {
        return new Bitmusa({ authKey : authKey });
    }

    /**
     * Sets the API base URL.
     * @param {string} baseURL - The API base URL.
     */
    setBaseURL(baseURL) {
        this.options.baseURL = baseURL;
    }

    /**
     * Sets the authentication key.
     * @param {string} authKey - The authentication key.
     */
    setAuthKey(authKey) {
        this.options.authKey = authKey;
    }

    /**
     * Returns the API base URL.
     * @returns {string} The API base URL.
     */
    getBaseURL() {
        return this.options.baseURL;
    }

    /**
     * Returns the authentication key.
     * @returns {string} The authentication key.
     */
    getAuthKey() {
        return this.options.authKey;
    }

    /**
     * Builds the request options object for the specified API endpoint and method.
     * @param {string} path - The API endpoint path.
     * @param {string} method - The HTTP method (GET, POST, etc.).
     * @param {Object|null} [parameter=null] - The request parameter object.
     * @returns {Object} The request options object.
     */
    buildRequestOptions(path, method, parameter = null) {

        let options = {
            url: this.options.baseURL + path,
            json: true,
            method: method.toUpperCase(),
            timeout: this.options.timeOut,
            cache: false,
            headers: {
                'x-auth-token': this.options.authKey,
                'Content-Type': 'application/json'
            }
        };

        if ((method.toUpperCase() === 'GET') &amp;&amp; (parameter)) {
            options.url += '?' + querystring.stringify(parameter);
        }

        if (parameter) {
            options = Object.assign(options, { body: parameter });
        }

        console.log(options);

        return options;
    }

    /**
     * Sends a sign-in request to the Bitmusa API with the specified email and password.
     * @param {string} email - The user's email.
     * @param {string} password - The user's password.
     * @returns {Promise} A Promise that resolves with the response body if the sign-in is successful, or rejects with an error message otherwise.
     */
    signIn(email, password) {
        return new Promise((resolve, reject) => {
            request(this.buildRequestOptions("/users/v1/signin", 'POST', { email: email, password: password }), (error, response, body) => {
                
                if (error)
                    reject(error);
                else {
                    if (response.statusCode !== 200) {
                        reject("statusCode : " + response.statusCode);
                    }

                    let json = typeof body === 'object' ? body : JSON.parse(body);
                    if (json.code !== 0) {
                        reject(json);
                    } else {
                        resolve(json);
                    }
                }
            });
        });
    } // end of signIn

    /**
     * Retrieves the user's asset balance from the Bitmusa API.
     * @returns {Promise} A Promise that resolves with the response body if the balance is retrieved successfully, or rejects with an error message otherwise.
     */
    balance() {
        return new Promise((resolve, reject) => {
            request(this.buildRequestOptions("/users/asset/wallet", 'GET'), (error, response, body) => {
                if (error)

                    reject(error);
                else {
                    if (response.statusCode !== 200) {
                        reject("statusCode : " + response.statusCode);
                    }

                    let json = typeof body === 'object' ? body : JSON.parse(body);
                    if (json.code !== 0) {
                        reject(json);
                    } else {
                        resolve(json);
                    }
                }
            });
        });
    } // end of balance

    /**
     * Places a buy order for the specified currency pair, amount, and price.
     * @param {string} pair - The currency pair to buy.
     * @param {number} amount - The amount of the currency to buy.
     * @param {string|null} [type=null] - The order type (MARKET_PRICE or LIMIT_PRICE).
     * @param {number|null} [price=null] - The price at which to buy the currency (required for LIMIT_PRICE orders).
     * @returns {Promise} A Promise that resolves with the response body if the order is placed successfully, or rejects with an error message otherwise.
     * @throws {Error} If the order type is LIMIT_PRICE and the price parameter is null.
     */
    buy(pair, amount, type = null, price = null) {
        var options = { 
            symbol : pair, 
            amount : amount+"",
            direction : 'BUY'
        };

        if ((type === null) || (type === 'MARKET_PRICE')) {
            options = Object.assign(options, { type: 'MARKET_PRICE', price: "0" });
        }

        if (type === 'LIMIT_PRICE') {
            // if price is null throw error
            if (price === null) {
                throw new Error('[buy] price is null');
            }

            options = Object.assign(options, { type: 'LIMIT_PRICE', price: price+"" });
        }

        return new Promise((resolve, reject) => {
            request(this.buildRequestOptions("/exchange/order/add", 'GET', options), (error, response, body) => {
                if (error)
                    reject(error);
                else {
                    if (response.statusCode !== 200) {
                        reject("statusCode : " + response.statusCode);
                    }

                    let json = typeof body === 'object' ? body : JSON.parse(body);
                    if (json.code !== 0) {
                         reject(json);
                    } else {
                         resolve(json);
                    }
                }
            });
        });
    } // end of buy

    /**
     * Places a sell order for the specified currency pair, amount, and price.
     * @param {string} pair - The currency pair to sell.
     * @param {number} amount - The amount of the currency to sell.
     * @param {string|null} [type=null] - The order type (MARKET_PRICE or LIMIT_PRICE).
     * @param {number|null} [price=null] - The price at which to sell the currency (required for LIMIT_PRICE orders).
     * @returns {Promise} A Promise that resolves with the response body if the order is placed successfully, or rejects with an error message otherwise.
     * @throws {Error} If the order type is LIMIT_PRICE and the price parameter is null.
     */
    sell(pair, amount, type = null, price = null) {
        var options = { 
            symbol : pair, 
            amount : amount+"",
            direction : 'SELL'
        };

        if ((type === null) || (type === 'MARKET_PRICE')) {
            options = Object.assign(options, { type: 'MARKET_PRICE', price: "0" });
        }

        if (type === 'LIMIT_PRICE') {
            // if price is null throw error
            if (price === null) {
                throw new Error('[sell] price is null');
            }

            options = Object.assign(options, { type: 'LIMIT_PRICE', price: price+"" });
        }

        return new Promise((resolve, reject) => {
            request(this.buildRequestOptions("/exchange/order/add", 'GET', options), (error, response, body) => {
                if (error)
                    reject(error);
                else {
                    if (response.statusCode !== 200) {
                        reject("statusCode : " + response.statusCode);
                    }

                    let json = typeof body === 'object' ? body : JSON.parse(body);
                    if (json.code !== 0) {
                         reject(json);
                    } else {
                         resolve(json);
                    }
                }
            });
        });
    } // end of sell

    /**
     * Cancels the order with the specified order ID.
     * @param {string} orderId - The ID of the order to cancel.
     * @returns {Promise} A Promise that resolves with the response body if the order is cancelled successfully, or rejects with an error message otherwise.
     */
    cancel(orderId) {
        return new Promise((resolve, reject) => {
            request(this.buildRequestOptions("/exchange/order/cancel/"+orderId, 'GET'), (error, response, body) => {
                if (error)
                    reject(error);
                else {
                    if (response.statusCode !== 200) {
                        reject("statusCode : " + response.statusCode);
                    }

                    let json = typeof body === 'object' ? body : JSON.parse(body);
                    if (json.code !== 0) {
                         reject(json);
                    } else {
                         resolve(json);
                    }
                }
            });
        });
    } // end of cancelOrder

    /**
     * Retrieves the user's open orders from the Bitmusa API.
     * @param {number} [page=1] - The page number to retrieve (default is 1).
     * @param {number} [size=10] - The page size to retrieve (default is 10).
     * @returns {Promise} A Promise that resolves with the response body if the orders are retrieved successfully, or rejects with an error message otherwise.
     */
    openOrders(page = 1, size = 10) {
        return new Promise((resolve, reject) => {
            request(this.buildRequestOptions("/exchange/order/personal/current", 'GET', { pageNo: page, pageSize: size }), (error, response, body) => {
                if (error)
                    reject(error);
                else {
                    if (response.statusCode !== 200) {
                        reject("statusCode : " + response.statusCode);
                    }

                    let json = typeof body === 'object' ? body : JSON.parse(body);
                    if (json.code !== 0) {
                         reject(json);
                    } else {
                         resolve(json);
                    }
                }
            });
        });
    } // end of openOrders

    
}


// export the class
module.exports = Bitmusa;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Bitmusa.html">Bitmusa</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Tue Feb 21 2023 00:19:16 GMT+0900 (대한민국 표준시)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
